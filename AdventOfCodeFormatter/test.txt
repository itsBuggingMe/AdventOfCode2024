Console.WriteLine(new Dictionary<int, string>() is { } inputCache && (object)((int day) => inputCache.TryGetValue(day, out var str) ? str : inputCache[day] = File.ReadAllText(Path.Combine(args.Length == 0 ? "" : args[0], $"day{day}.aoc")).ReplaceLineEndings("\n")) is Func<int, string> load && (object)((int day, Func<string, object> part1, Func<string, object> part2) => new System.Text.StringBuilder().AppendLine($"Day {day}:").AppendLine("Part 1:").AppendLine(part1(load(day)).ToString()).AppendLine("Part 2:").AppendLine(part2(load(day)).ToString()).AppendLine().ToString()) is Func<int, Func<string, object>, Func<string, object>, string> day ? new System.Text.StringBuilder().Append(day(1, input => input.Split('\n').Select(s => s.Split("   ")).Aggregate((new System.Text.StringBuilder(), new System.Text.StringBuilder()), (t, s) => (t.Item1.Append(' ').Append(s[0]), t.Item2.Append(' ').Append(s[1])), t => t.Item1.ToString().Split(' ').Skip(1).Select(int.Parse).OrderBy(i => i).Zip(t.Item2.ToString().Split(' ').Skip(1).Select(int.Parse).OrderBy(i => i))).Select(t => t.First - t.Second).Sum(Math.Abs), input => input.Split('\n').Select(s => s.Split("   ")).Aggregate((new System.Text.StringBuilder(), new System.Text.StringBuilder()), (t, s) => (t.Item1.Append(' ').Append(s[0]), t.Item2.Append(' ').Append(s[1])), t => t.Item1.ToString().Split(' ').Skip(1).Select(s => (int.Parse(s), t.Item2.ToString().Split(' ').Skip(1).Select(int.Parse).GroupBy(i => i).ToDictionary(l => l.Key)))).Sum(t => (t.Item2.TryGetValue(t.Item1, out var group) ? group.Count() : 0) * t.Item1))).AppendLine(day(2, input => input.Split('\n').Select(s => s.Split(' ')).Select(s => s.Select(int.Parse)).Select(s => s.Zip(s.Skip(1)).Select(t => t.First - t.Second)).Where(s => s.All(a => Math.Sign(a) == Math.Sign(s.First()) && a != 0 && Math.Abs(a) <= 3)).Count(), input => input.Split('\n').Select(s => s.Split(' ')).Select(s => s.Select(int.Parse)).Select(s => s.ToList()).Where(s => s.Zip(s.Skip(1)).Select(t => (Math.Sign(s[0] - s[1]), t)).All(t => Math.Abs(t.Item2.First - t.Item2.Second) is <= 3 and not 0 && Math.Sign(t.Item2.First - t.Item2.Second) == t.Item1) || Enumerable.Range(0, s.Count).Any(i => Array.Empty<int>().Aggregate(s.Where((_, index) => index != i).ToList(), (a, b) => null!, s => s.Zip(s.Skip(1)).Select(t => (Math.Sign(s[0] - s[1]), t)).All(t => Math.Abs(t.Item2.First - t.Item2.Second) is <= 3 and not 0 && Math.Sign(t.Item2.First - t.Item2.Second) == t.Item1)))).Count())).AppendLine(day(3, input => System.Text.RegularExpressions.Regex.Matches(input, @"(?<=mul\()[0-9]+,[0-9]+(?=\))").Sum(s => s.Value.IndexOf(',') is { } index ? (int.Parse(s.ValueSpan[..index]) * int.Parse(s.ValueSpan[(index + 1)..])) : 1), input => input.Split("do()").Select(s => s.IndexOf("don't()") is { } index && index != -1 ? s[..index] : s).Sum(s => System.Text.RegularExpressions.Regex.Matches(s, @"(?<=mul\()[0-9]+,[0-9]+(?=\))").Sum(s => s.Value.IndexOf(',') is { } index ? (int.Parse(s.ValueSpan[..index]) * int.Parse(s.ValueSpan[(index + 1)..])) : 1)))).AppendLine(day(4, input => input.IndexOf('\n') is int width && Array.Empty<int>().Aggregate(((int, int) a, (int, int) b) => (a.Item1 + b.Item1, a.Item2 + b.Item2), (f, n) => null!) is Func<(int, int), (int, int), (int, int)> add && new (int, int)[] { (-1, -1), (-1, 0), (-1, +1), (0, -1), (0, +1), (+1, -1), (+1, 0), (+1, +1) } is { } deltas ? input.Replace("\n", "").Select((@char, index) => (index, @char)).Aggregate(new Dictionary<(int, int), char>(), (dict, @char) => dict.TryAdd((@char.index % width, @char.index / width), @char.@char) is true ? dict : throw new Exception($"Key for {@char} already in dict!")) is { } table ? table.Select(kvp => deltas.Sum(dxy => !"XMAS".Aggregate((false, kvp.Key), (flagpos, @char) => (flagpos.Item1 || !(table.TryGetValue(flagpos.Item2, out char v) && v == @char), add(flagpos.Item2, dxy))).Item1 ? 1 : 0)).Sum() : throw null! : throw null!, input => input.IndexOf('\n') is int width && Array.Empty<int>().Aggregate((Dictionary<(int, int), char> t, (int, int) v) => t.TryGetValue(v, out char res) ? res : '\0', (f, n) => null!) is Func<Dictionary<(int, int), char>, (int, int), char> getOrDefault && Array.Empty<int>().Aggregate(((int, int) a, (int, int) b) => (a.Item1 + b.Item1, a.Item2 + b.Item2), (f, n) => null!) is Func<(int, int), (int, int), (int, int)> add && Array.Empty<int>().Aggregate((Dictionary<(int, int), char> words, (int, int) loc) => words[loc] == 'A' && ((getOrDefault(words, add(loc, (1, 1))) == 'M' && getOrDefault(words, add(loc, (-1, -1))) == 'S') || (getOrDefault(words, add(loc, (1, 1))) == 'S' && getOrDefault(words, add(loc, (-1, -1))) == 'M')) && ((getOrDefault(words, add(loc, (-1, 1))) == 'M' && getOrDefault(words, add(loc, (1, -1))) == 'S') || (getOrDefault(words, add(loc, (-1, 1))) == 'S' && getOrDefault(words, add(loc, (1, -1))) == 'M')), (f, n) => null!) is Func<Dictionary<(int, int), char>, (int, int), bool> checkIsXMAS ? input.Replace("\n", "").Select((@char, index) => (index, @char)).Aggregate(new Dictionary<(int, int), char>(), (dict, @char) => dict.TryAdd((@char.index % width, @char.index / width), @char.@char) is true ? dict : throw new Exception($"Key for {@char} already in dict!")) is { } table ? table.Where(kvp => checkIsXMAS(table, kvp.Key)).Count() : throw null! : throw null!)).AppendLine(day(5, input => System.Text.RegularExpressions.Regex.Matches(input, @"(\d+)\|(\d+)").Select(m => (int.Parse(m.Groups[1].ValueSpan), int.Parse(m.Groups[2].ValueSpan))).ToLookup(t => t.Item1) is ILookup<int, (int, int)> table ? System.Text.RegularExpressions.Regex.Matches(input, @"(\d+,)+\d+").Select(m => m.Value.Split(',').Select(int.Parse)).Where(t => t.Select((num, index) => (index, num)).TakeWhile(e => t.Take(e.index).All(pn => !table[e.num].Contains((e.num, pn)))).Count() == t.Count()).Select(a => a.Skip(a.Count() / 2).First()).Sum() : throw null!, input => System.Text.RegularExpressions.Regex.Matches(input, @"(\d+)\|(\d+)").Select(m => (int.Parse(m.Groups[1].ValueSpan), int.Parse(m.Groups[2].ValueSpan))).ToLookup(t => t.Item1) is ILookup<int, (int, int)> table ? System.Text.RegularExpressions.Regex.Matches(input, @"(\d+,)+\d+").Select(m => m.Value.Split(',').Select(int.Parse)).Where(t => t.Select((num, index) => (index, num)).TakeWhile(e => t.Take(e.index).All(pn => !table[e.num].Contains((e.num, pn)))).Count() != t.Count()).Select(i => i.OrderBy(n => n, Comparer<int>.Create((a, b) => !table[a].Contains((a, b)) ? 1 : -1))).Select(a => a.Skip(a.Count() / 2).First()).Sum() : throw null!)).AppendLine(day(6, input => input.IndexOf('\n') is int accWidth && new int[] { -accWidth - 1, 1, accWidth + 1, -1, 0, input.IndexOf('^') } is int[] dirs && Array.Empty<int>().Aggregate((int i) => unchecked((uint)i) < unchecked((uint)input.Length) ? input[i] : '\n', (a, b) => null!) is Func<int, char> charAt ? Enumerable.Range(0, int.MaxValue).Select(i => (dirs[5], charAt(dirs[dirs[4] % 4] + dirs[5]) == '#' ? dirs[4]++ : (dirs[5] += dirs[dirs[4] % 4]))).TakeWhile(i => charAt(i.Item1) != '\n').Select(i => i.Item1).ToHashSet().Count : throw null!, input => input.ToArray() is char[] buffer && input.IndexOf('\n') is int accWidth && new int[] { -accWidth - 1,/*0*/ 1,/*1*/ accWidth + 1,/*2*/ -1,/*3*/ 0/*4*/, input.IndexOf('^')/*5*/, input.IndexOf('^') } is int[] dirs && Array.Empty<int>().Aggregate((int i) => unchecked((uint)i) < unchecked((uint)buffer.Length) ? buffer[i] : '\n', (a, b) => null!) is Func<int, char> charAt ? buffer.Select((c, index) => (index, c)).Where(t => t.c == '.').Where(t => (dirs[4] = 0) == 0 && (dirs[5] = dirs[6]) != -1 && (buffer[t.index] = '#') == '#' && new Dictionary<(int, int), int>() is Dictionary<(int, int), int> alreadyValues && Enumerable.Range(0, int.MaxValue).Select(i => (ticks: i, gindex: dirs[5], garbage: charAt(dirs[dirs[4]] + dirs[5]) == '#' ? dirs[4] = (dirs[4] + 1) % 4 : (dirs[5] += dirs[dirs[4]]))).Select(i => (isAlreadyHere: alreadyValues.ContainsKey((i.gindex, dirs[4])) && alreadyValues.Last().Key != (i.gindex, dirs[4]), isOffMap: charAt(i.gindex) == '\n', alreadyValues[(i.gindex, dirs[4])] = 0)).First(t => t.isAlreadyHere || t.isOffMap).isAlreadyHere & (buffer[t.index] = '.') == '.').Count() : throw null!)).AppendLine(day(7, input => input.Split('\n').Select(s => (head: long.Parse(s.AsSpan(0, s.IndexOf(':'))), tail: s[(s.IndexOf(':') + 2)..].Split(' ').Select(long.Parse).ToArray())).Where(t => Enumerable.Range(0, 1 << (t.tail.Length - 1)).Any(b => t.tail.Skip(1).Aggregate((bits: b, val: t.tail[0]), (num, acc) => (num.bits >> 1, (num.bits & 1) == 0 ? acc * num.val : acc + num.val)).val == t.head)).Sum(t => t.head), input => input.Split('\n').Select(s => (head: long.Parse(s.AsSpan(0, s.IndexOf(':'))), tail: s[(s.IndexOf(':') + 2)..].Split(' ').Select(long.Parse).ToArray())).Where(t => Enumerable.Range(0, Enumerable.Range(0, t.tail.Length - 1).Aggregate(1, (n, a) => n * 3)).Any(b => t.tail.Skip(1).Aggregate((bits: b, val: t.tail[0]), (num, acc) => (bits: num.bits / 3, val: num.bits % 3 == 0 ? acc * num.val : num.bits % 3 == 1 ? acc + num.val : long.Parse($"{num.val}{acc}"))).val == t.head)).Sum(t => t.head))).AppendLine(day(8, input => /*tuple lib lol*/ (object)(((int x, int y) a, (int x, int y) b) => (a.x + b.x, a.y + b.y)) is Func<(int, int), (int, int), (int, int)> add && (object)(((int x, int y) a, (int x, int y) b) => (a.x - b.x, a.y - b.y)) is Func<(int, int), (int, int), (int, int)> sub && (object)(((int x, int y) a, (int x, int y) b) => (a.x * b.x, a.y * b.y)) is Func<(int, int), (int, int), (int, int)> mul && input.IndexOf('\n') is int width && (int)Math.Round(input.Length / (width + 1f)) is int height && (object)(((int x, int y) a) => a.x >= 0 && a.y >= 0 && a.x < width && a.y < height) is Func<(int, int), bool> inRange ? input.Where(t => t != '\n').Select((c, index) => (x: index % width, y: index / width, @char: c)).Where(c => c.@char != '.').ToLookup(c => c.@char, c => (c.x, c.y)).SelectMany(grouping => grouping.SelectMany(i => grouping.Select(j => (left: i, right: j)).Where(t => t.left != t.right).Select(t => add(t.left, mul((2, 2), sub(t.right, t.left))) is { } node && inRange(node) ? node : (-1, -1)))).Distinct().Count() - 1 : throw null!, input => (object)(((int x, int y) a, (int x, int y) b) => (a.x + b.x, a.y + b.y)) is Func<(int, int), (int, int), (int, int)> add && (object)(((int x, int y) a, (int x, int y) b) => (a.x - b.x, a.y - b.y)) is Func<(int, int), (int, int), (int, int)> sub && (object)(((int x, int y) a, (int x, int y) b) => (a.x * b.x, a.y * b.y)) is Func<(int, int), (int, int), (int, int)> mul && input.IndexOf('\n') is int width && (int)Math.Round(input.Length / (width + 1f)) is int height ? input.Where(t => t != '\n').Select((c, index) => (x: index % width, y: index / width, @char: c)).Where(c => c.@char != '.').ToLookup(c => c.@char, c => (c.x, c.y)).SelectMany(grouping => grouping.SelectMany(i => grouping.Select(j => (left: i, right: j)).Where(t => t.left != t.right).SelectMany(t => Enumerable.Range(0, int.MaxValue).Select(i => add(t.left, mul(sub(t.right, t.left), (i, i)))).TakeWhile(((int x, int y) a) => a.x >= 0 && a.y >= 0 && a.x < width && a.y < height)))).Distinct().Count() : throw null!)).AppendLine(day(9, input => input.SelectMany((i, index) => Enumerable.Range(0, i - '0').Select(n => index % 2 == 0 ? index / 2 : -1)).ToArray() is int[] buff && new int[2] { 0, buff.Length } is int[] vars && Enumerable.Range(0, int.MaxValue).Select(s => buff[s] == -1 ? (buff[s] = buff.Take(vars[1]).Reverse().First(i => (buff[--vars[1]] = -1) * 0 + i != -1)) * 0 + s : s).TakeWhile(i => i < vars[1]).Count() != -1 ? buff.Where(i => i != -1).Select((i, j) => (long)i * j).Sum() : throw null!, input => input.SelectMany((i, index) => Enumerable.Range(0, i - '0').Select(n => index % 2 == 0 ? index / 2 : -1)).ToArray() is int[] buff && buff.Select((id, index) => (id, index)).GroupBy(i => i.id).Where(g => g.Key != -1).Select(g => (Id: g.Key, Index: g.First().index, Length: g.Count())).Reverse().ToArray().Count(file => Enumerable.Range(0, buff.Length).FirstOrDefault(i => buff.AsSpan(i).StartsWith((stackalloc int[9] { -1, -1, -1, -1, -1, -1, -1, -1, -1, }).Slice(0, file.Length))) is int replacementIndex && replacementIndex != 0 && replacementIndex < file.Index ? Enumerable.Range(0, file.Length).Count(offset => (buff[replacementIndex + offset] = buff[file.Index + offset]) + (buff[file.Index + offset] = -1) == 0) == 0 : false) is { } ? buff.Select((i, j) => i == -1 ? 0 : (long)i * j).Sum() : throw null!)).AppendLine(day(10, input => new Func<string, int, int, int, HashSet<int>, int>[1] is { } arr && (arr[0] = (string str, int width, int x, int pElevation, HashSet<int> set) => x >= str.Length || x < 0 || str[x] == '\n' || str[x] == '.' || str[x] - '0' != ++pElevation || !set.Add(x) ? 0 : str[x] == '9' ? 1 : arr[0](str, width, x + 1, pElevation, set) + arr[0](str, width, x - 1, pElevation, set) + arr[0](str, width, x - width - 1, pElevation, set) + arr[0](str, width, x + width + 1, pElevation, set)) is { } recur ? input.Select((i, j) => (j, i)).Where(t => t.i == '0').Sum(t => recur(input, input.IndexOf('\n'), t.j, -1, new HashSet<int>())) : throw null!, input => new Func<string, int, int, int, int>[1] is { } arr && (arr[0] = (string str, int width, int x, int pElevation) => x >= str.Length || x < 0 || str[x] == '\n' || str[x] == '.' || str[x] - '0' != ++pElevation ? 0 : str[x] == '9' ? 1 : arr[0](str, width, x + 1, pElevation) + arr[0](str, width, x - 1, pElevation) + arr[0](str, width, x - width - 1, pElevation) + arr[0](str, width, x + width + 1, pElevation)) is { } recur ? input.Select((i, j) => (j, i)).Where(t => t.i == '0').Sum(t => recur(input, input.IndexOf('\n'), t.j, -1)) : throw null!)).AppendLine(day(11, input => (object)((object obj, long n, int cycle) => obj is Func<object, long, int, long> self ? cycle-- == 0 ? 1 : n == 0 ? self(self, 1, cycle) : (long)Math.Ceiling(Math.Log10(n + 1)) is { } digits && digits % 2 == 0 && (long)Math.Pow(10, digits / 2) is { } block ? self(self, n / block, cycle) + self(self, n % block, cycle) : self(self, n * 2024, cycle) : throw null!) is Func<object, long, int, long> recur ? input.Split(' ').Select(int.Parse).Sum(f => recur(recur, f, 25)) : throw null!, input => (object)((object obj, Dictionary<(long N, int Cycle), long> cache, long n, int cycle) => cache.TryGetValue((n, cycle), out long count) ? count : cache[(n, cycle)] = obj is Func<object, Dictionary<(long Start, int Left), long>, long, int, long> self ? cycle-- == 0 ? 1 : n == 0 ? self(self, cache, 1, cycle) : (long)Math.Ceiling(Math.Log10(n + 1)) is { } digits && digits % 2 == 0 && (long)Math.Pow(10, digits / 2) is { } block ? self(self, cache, n / block, cycle) + self(self, cache, n % block, cycle) : self(self, cache, n * 2024, cycle) : throw null!) is Func<object, Dictionary<(long Start, int Left), long>, long, int, long> recur ? input.Split(' ').Select(int.Parse).Sum(f => recur(recur, new(), f, 75)) : throw null!)).AppendLine(day(12, input => input.IndexOf('\n') is int inputWidth && new int[] { 1, -1, -inputWidth - 1, inputWidth + 1 } is { } deltas && new HashSet<int>() is { } large ? input.Select((c, i) => (i, c)).Where(c => c.c != '\n').Select(c => (object)((object self, string str, int width, int x, char tile, int[] deltas, HashSet<int> set, HashSet<int> total) => x >= str.Length || x < 0 || str[x] != tile || !total.Add(x) || !set.Add(x) || self is not Func<object, string, int, int, char, int[], HashSet<int>, HashSet<int>, HashSet<int>> func ? set : deltas.Select(i => func(self, str, width, x + i, tile, deltas, set, total)).Where(t => true).Last()) is Func<object, string, int, int, char, int[], HashSet<int>, HashSet<int>, HashSet<int>> func ? (set: func(func, input, inputWidth, c.i, c.c, deltas, new(), large), c.c) : throw null!).Where(t => t.set.Count != 0).Sum(t => t.set.Count * t.set.Sum(p => deltas.Where(d => p + d is int x && (x < 0 || x >= input.Length || input[x] != t.c)).Count())) : throw null!, input => input.IndexOf('\n') is int inputWidth && new int[] { 1, -1, -inputWidth - 1, inputWidth + 1 } is { } deltas && new HashSet<int>() is { } large ? input.Select((c, i) => (i, c)).Where(c => c.c != '\n').Select(c => (object)((object self, string str, int width, int x, char tile, int[] deltas, HashSet<int> set, HashSet<int> total) => x >= str.Length || x < 0 || str[x] != tile || !total.Add(x) || !set.Add(x) || self is not Func<object, string, int, int, char, int[], HashSet<int>, HashSet<int>, HashSet<int>> func ? set : deltas.Select(i => func(self, str, width, x + i, tile, deltas, set, total)).Where(t => true).Last()) is Func<object, string, int, int, char, int[], HashSet<int>, HashSet<int>, HashSet<int>> func ? (set: func(func, input, inputWidth, c.i, c.c, deltas, new(), large), c.c) : throw null!).Where(t => t.set.Count != 0).Sum(t => t.set.SelectMany(p => deltas.Where(d => p + d is int x && (x < 0 || x >= input.Length || input[x] != t.c)).Select(d => (normal: d, pos: p))).GroupBy(a => Math.Abs(a.normal) == 1 ? (a.normal, a.pos % (inputWidth + 1)) : (a.normal, a.pos / (inputWidth + 1))).Select(a => a.OrderBy(c => c.pos)).Sum(a => a.Skip(1).Aggregate((sum: 1, prev: a.First().pos, expected: Math.Abs(a.First().normal) == 1 ? (inputWidth + 1) : 1), (a, c) => (sum: a.sum + (a.prev + a.expected != c.pos ? 1 : 0), prev: c.pos, a.expected)).sum) * t.set.Count) : throw null!)).AppendLine(day(13, input => System.Text.RegularExpressions.Regex.Matches(input, @"(\d+)\D*(\d+)\D*(\d+)\D*(\d+)\D*(\d+)\D*(\d+)").Select(m => (a1: double.Parse(m.Groups[1].ValueSpan), a2: double.Parse(m.Groups[2].ValueSpan), b1: double.Parse(m.Groups[3].ValueSpan), b2: double.Parse(m.Groups[4].ValueSpan), c1: double.Parse(m.Groups[5].ValueSpan), c2: double.Parse(m.Groups[6].ValueSpan))).Select(t => -t.a1 / t.a2 is { } m && (t.c1 + t.c2 * m) / (t.b1 + m * t.b2) is { } y && (-t.b1 * y + t.c1) / t.a1 is { } x ? (x, y) : throw null!).Sum(t => Math.Abs(Math.Round(t.x) + Math.Round(t.y) - t.x - t.y) < 0.0001 && t.x < 100 && t.y < 100 ? t.x * 3 + t.y : 0), input => System.Text.RegularExpressions.Regex.Matches(input, @"(\d+)\D*(\d+)\D*(\d+)\D*(\d+)\D*(\d+)\D*(\d+)").Select(m => (a1: double.Parse(m.Groups[1].ValueSpan), a2: double.Parse(m.Groups[2].ValueSpan), b1: double.Parse(m.Groups[3].ValueSpan), b2: double.Parse(m.Groups[4].ValueSpan), c1: double.Parse(m.Groups[5].ValueSpan) + 10000000000000, c2: double.Parse(m.Groups[6].ValueSpan) + 10000000000000)).Select(t => -t.a1 / t.a2 is { } m && (t.c1 + t.c2 * m) / (t.b1 + m * t.b2) is { } y && (-t.b1 * y + t.c1) / t.a1 is { } x ? (x, y) : throw null!).Sum(t => Math.Abs(Math.Round(t.x) - t.x) < 0.001 && Math.Abs(Math.Round(t.y) - t.y) < 0.001 ? t.x * 3 + t.y : 0))).AppendLine(day(14, input => System.Text.RegularExpressions.Regex.Matches(input, @"=(-?\d+),(-?\d+)..=(-?\d+),(-?\d+)").Select(s => (x: int.Parse(s.Groups[1].ValueSpan) + 20200000, y: int.Parse(s.Groups[2].ValueSpan) + 20600000, dx: int.Parse(s.Groups[3].ValueSpan), dy: int.Parse(s.Groups[4].ValueSpan))).Select(s => (x: (s.x + s.dx * 100) % 101, y: (s.y + s.dy * 100) % 103)).Aggregate(new int[5], (a, g) => a[g switch { ( > 50, < 51) => 0, ( < 50, < 51) => 1, ( > 50, > 51) => 2, ( < 50, > 51) => 3, _ => 4, }]++ == -1 ? a : a, t => t[0] * t[1] * t[2] * t[3]), input => System.Text.RegularExpressions.Regex.Matches(input, @"=(-?\d+),(-?\d+)..=(-?\d+),(-?\d+)").Select(s => (x: int.Parse(s.Groups[1].ValueSpan) + 20200000, y: int.Parse(s.Groups[2].ValueSpan) + 20600000, dx: int.Parse(s.Groups[3].ValueSpan), dy: int.Parse(s.Groups[4].ValueSpan))).ToArray() is { } initpos && new bool[101 * 103] is bool[] buff ? Enumerable.Range(0, int.MaxValue).First(t => (buff = new bool[101 * 103]) is { } && initpos.All(s => (s.x + s.dx * t) % 101 + (s.y + s.dy * t) % 103 * 101 is int index && buff[index] ? false : buff[index] = true)) : throw null!)).AppendLine(day(15, input => input.Split("\n\n") is { } arr && arr[0].Split('\n').Select(s => s.Replace('@', '.').ToArray()).ToArray() is char[][] buffer && input.IndexOf('\n') is int width && arr[1].Replace("\n", "") is string instruction && (input.IndexOf('@') % (width + 1)) is int px && (input.IndexOf('@') / (width + 1)) is int py && (object)((int dx, int dy, int max) => Enumerable.Range(1, max - 1).Select(i => (x: px + dx * i, y: py + dy * i)).Select(t => (t.x, t.y, buffer[t.y][t.x])).First(t => t.Item3 != 'O') is { } last && last.Item3 == '#' ? false : ((buffer[py + dy][px + dx], buffer[last.y][last.x]) = (buffer[last.y][last.x], buffer[py + dy][px + dx])) is { }) is Func<int, int, int, bool> step && instruction.Select(c => c switch { '<' => step(-1, 0, px + 1) ? px-- : px, '>' => step(1, 0, width - px) ? px++ : px, '^' => step(0, -1, py + 1) ? py-- : px, 'v' => step(0, 1, width - py) ? py++ : px, _ => throw new Exception($"Rogue {c} character in instructions!") }).Count() != -1 ? buffer.SelectMany((i, j) => i.Select((c, k) => (c, x: k, y: j))).Where(c => c.c == 'O').Sum(t => t.x + t.y * 100) : throw null!, input => (input = input!.Replace("#", "##").Replace("O", "[]").Replace(".", "..").Replace("@", "@.")) is { } && input.Split("\n\n") is { } arr && arr[0].Split('\n').Select(s => s.Replace('@', '.').ToArray()).ToArray() is char[][] buffer && input.IndexOf('\n') is int width && arr[1].Replace("\n", "") is string instruction && (input.IndexOf('@') % (width + 1)) is int px && (input.IndexOf('@') / (width + 1)) is int py && (object)((object s, int bx, int by, int dx, int dy, HashSet<(int, int)> prev) => s is Func<object, int, int, int, int, HashSet<(int, int)>, bool> self ? buffer[by][bx] switch { '[' => (!prev.Add((bx, by)) & !prev.Add((bx + 1, by))) ? false : self(s, bx + dx, by + dy, dx, dy, prev) || self(s, bx + dx + 1, by + dy, dx, dy, prev), ']' => (!prev.Add((bx, by)) & !prev.Add((bx - 1, by))) ? false : self(s, bx + dx, by + dy, dx, dy, prev) || self(s, bx + dx - 1, by + dy, dx, dy, prev), '#' => true, '.' => false, _ => throw new Exception($"Rogue {buffer[bx][by]} character in warehouse!") } : throw null!) is Func<object, int, int, int, int, HashSet<(int, int)>, bool> isBlocked && instruction.Select(c => new HashSet<(int x, int y)>() is HashSet<(int x, int y)> set && 0 is int dx && 0 is int dy ? (c switch { '<' => isBlocked(isBlocked, px - 1, py, dx = -1, 0, set = new()) ? (0, false) : (px--, true), '>' => isBlocked(isBlocked, px + 1, py, dx = 1, 0, set = new()) ? (0, false) : (px++, true), '^' => isBlocked(isBlocked, px, py - 1, 0, dy = -1, set = new()) ? (0, false) : (py--, true), 'v' => isBlocked(isBlocked, px, py + 1, 0, dy = 1, set = new()) ? (0, false) : (py++, true), _ => throw new Exception($"Rogue {c} character in instructions!") }).Item2 ? set.OrderBy(box => (-dy * box.y) * 100 + -dx * box.x).Select(t => (buffer[t.y + dy][t.x + dx], buffer[t.y][t.x]) = (buffer[t.y][t.x], buffer[t.y + dy][t.x + dx])).Count() : 0 : throw null!).Count() != -1 ? buffer.SelectMany((i, j) => i.Select((c, k) => (c, x: k, y: j))).Where(c => c.c == '[').Sum(t => t.x + t.y * 100) : throw null!)).AppendLine(day(16, input => input.IndexOf('\n') + 1 is { } width && new int[] { -width, 1, width, -1 } is { } deltaTable && (object)(((int, int) current, Func<(int, int), IEnumerable<((int, int) Location, int Weight)>> getEdges) => new HashSet<(int, int)>() is { } visited && (new Dictionary<(int, int), int> { { current, 0 }, }) is { } costs && Enumerable.Range(0, int.MaxValue).Select(_ => getEdges(current).Select(t => costs.TryGetValue(t.Location, out int cost) ? costs[t.Location] = Math.Min(cost, costs[current] + t.Weight) : costs[t.Location] = costs[current] + t.Weight).Count()).Select(t => visited.Add(current) && (current = costs.MinBy(t => visited.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { }).TakeWhile(t => !visited.Contains(current)).Count() is { } ? costs : throw null!) is Func<(int, int), Func<(int Pos, int Dir), IEnumerable<((int, int) Location, int Weight)>>, Dictionary<(int, int), int>> dijkstra && dijkstra((input.IndexOf('S'), 1), t => t.Pos + deltaTable[t.Dir] is int forward && forward >= 0 && forward < input.Length && input[forward] != '\n' && input[forward] != '#' ? new ((int, int), int)[] { ((forward, t.Dir), 1), ((t.Pos, (t.Dir + 4 + 1) % 4), 1000), ((t.Pos, (t.Dir + 4 - 1) % 4), 1000) } : new ((int, int), int)[] { ((t.Pos, (t.Dir + 4 + 1) % 4), 1000), ((t.Pos, (t.Dir + 4 - 1) % 4), 1000) }) is { } dists ? new int[] { dists[(input.IndexOf('E'), 0)], dists[(input.IndexOf('E'), 1)], dists[(input.IndexOf('E'), 2)], dists[(input.IndexOf('E'), 3)] }.Min() : throw null!, input => input.IndexOf('\n') + 1 is { } width && input.IndexOf('E') is { } exit && new int[] { -width, 1, width, -1 } is { } deltaTable && (object)(((int, int) current, Func<(int, int), IEnumerable<((int, int) Location, int Weight)>> getEdges) => new HashSet<(int, int)>() is { } visited && (new Dictionary<(int, int), int> { { current, 0 }, }) is { } costs && Enumerable.Range(0, int.MaxValue).Select(_ => getEdges(current).Select(t => costs.TryGetValue(t.Location, out int cost) ? costs[t.Location] = Math.Min(cost, costs[current] + t.Weight) : costs[t.Location] = costs[current] + t.Weight).Count()).Select(t => visited.Add(current) && (current = costs.MinBy(t => visited.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { }).TakeWhile(t => !visited.Contains(current)).Count() is { } ? costs : throw null!) is Func<(int, int), Func<(int Pos, int Dir), IEnumerable<((int, int) Location, int Weight)>>, Dictionary<(int, int), int>> dijkstra && dijkstra((input.IndexOf('S'), 1), t => t.Pos + deltaTable[t.Dir] is int forward && forward >= 0 && forward < input.Length && input[forward] != '\n' && input[forward] != '#' ? new ((int, int), int)[] { ((forward, t.Dir), 1), ((t.Pos, (t.Dir + 4 + 1) % 4), 1000), ((t.Pos, (t.Dir + 4 - 1) % 4), 1000) } : new ((int, int), int)[] { ((t.Pos, (t.Dir + 4 + 1) % 4), 1000), ((t.Pos, (t.Dir + 4 - 1) % 4), 1000) }) is { } dists && (object)((object self, HashSet<(int, int)> set, (int Pos, int Dir) current, int expected) => self is Func<object, HashSet<(int, int)>, (int Pos, int Dir), int, HashSet<(int, int)>> x && current.Pos >= 0 && current.Pos < input.Length && input[current.Pos] != '\n' && input[current.Pos] != '#' && dists[current] == expected && set.Add(current) ? (x(x, set, (current.Pos, (current.Dir + 4 + 1) % 4), expected - 1000), x(x, set, (current.Pos, (current.Dir + 4 - 1) % 4), expected - 1000), x(x, set, (current.Pos - deltaTable[current.Dir], current.Dir), expected - 1)).Item1 : set) is Func<object, HashSet<(int, int)>, (int Pos, int Dir), int, HashSet<(int, int)>> floodfill && Enumerable.Range(0, 4).MinBy(t => dists[(exit, t)]) is { } mindex ? floodfill(floodfill, new(), (exit, mindex), dists[(exit, mindex)]).DistinctBy(t => t.Item1).Count() : throw null!)).AppendLine(day(17, input => System.Text.RegularExpressions.Regex.Matches(input, @"\d+").Select(s => long.Parse(s.ValueSpan)).ToArray() is { } p && p[..3] is { } reg && p[3..] is { } program && (object)((long i) => program[i + 1] is { } op && op < 4 ? op : reg[op - 4]) is Func<long, long> combo && 0L is { } pc ? string.Join(',', Enumerable.Range(0, int.MaxValue).Select(t => pc < program.Length ? program[pc] switch { 0 => (reg[0] = reg[0] / (1 << (int)combo(pc)), 0), 1 => (reg[1] ^= program[pc + 1], 0), 2 => (reg[1] = combo(pc) & 7, 0), 3 => (reg[0] == 0 ? 0 : pc = program[pc + 1] - 2, 0), 4 => (reg[1] ^= reg[2], 0), 5 => (combo(pc) & 7, 1), 6 => (reg[1] = reg[0] / (1 << (int)combo(pc)), 0), 7 => (reg[2] = reg[0] / (1 << (int)combo(pc)), 0), _ => throw new Exception() } : (0, -1)).Select(t => (pc += 2) is { } ? t : throw null!).TakeWhile(t => t.Item2 != -1).Where(t => t.Item2 == 1).Select(t => t.Item1)) : throw null!, input => System.Text.RegularExpressions.Regex.Matches(input, @"\d+").Select(s => long.Parse(s.ValueSpan)).ToArray() is { } p && (object)((long[] p) => p[..3] is { } reg && p[3..] is { } program && (object)((long i) => program[i + 1] is { } op && op < 4 ? op : reg[op - 4]) is Func<long, long> combo && 0L is { } pc ? Enumerable.Range(0, int.MaxValue).Select(t => pc < program.Length ? program[pc] switch { 0 => (reg[0] = reg[0] / (1 << (int)combo(pc)), 0), 1 => (reg[1] ^= program[pc + 1], 0), 2 => (reg[1] = combo(pc) & 7, 0), 3 => (reg[0] == 0 ? 0 : pc = program[pc + 1] - 2, 0), 4 => (reg[1] ^= reg[2], 0), 5 => (combo(pc) & 7, 1), 6 => (reg[1] = reg[0] / (1 << (int)combo(pc)), 0), 7 => (reg[2] = reg[0] / (1 << (int)combo(pc)), 0), _ => throw new Exception() } : (0, -1)).Select(t => (pc += 2) is { } ? t : throw null!).TakeWhile(t => t.Item2 != -1).Where(t => t.Item2 == 1).Select(t => (int)t.Item1) : throw null!) is Func<long[], IEnumerable<int>> runProgram && 0L is { } currentGuess && p[3..].Select(i => (int)i).Reverse().ToArray() is { } instruction && 1 is { } nowMatch && Enumerable.Range(0, int.MaxValue).Select(i => p[2] = p[1] = 0).Select(i => p[0] = currentGuess).Select(i => runProgram(p).Reverse().SequenceEqual(instruction.Take(nowMatch)) ? ++nowMatch + (currentGuess *= 8) : currentGuess++).TakeWhile(i => nowMatch != p.Length - 2).Count() != -1 ? currentGuess / 8 : throw null!)).AppendLine(day(18, input => Enumerable.Repeat('.', 71).SelectMany(i => Enumerable.Repeat(i, 71).Append('\n')).ToArray() is { } buff && input.Split('\n').Take(1024).Select(i => i.Split(',')).Select(i => (x: int.Parse(i[0]), y: int.Parse(i[1]))).Select(i => buff[i.x + i.y * 72] = '#').Count() is { } && new int[] { 1, -1, 72, -72 } is { } deltas && 0 is { } current && Enumerable.Range(0, buff.Length).Where(i => buff[i] == '.').ToDictionary(t => t, t => t == 0 ? 0 : int.MaxValue - 1) is { } dists && new HashSet<int>() is { } finished && Enumerable.Range(0, int.MaxValue).Select(y => dists[current]).Select(y => deltas.Select(t => current + t).Select(t => t >= 0 && t < buff.Length && dists.TryGetValue(t, out int oldDist) && oldDist > y + 1 ? dists[t] = y + 1 : 0).Count() != -1 && (finished.Add(current) & (current = dists.MinBy(t => finished.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { })).TakeWhile(t => finished.Count < 71 * 71 - 1024).Count() is { } ? dists[71 * 72 - 2] : throw null!, input => Enumerable.Repeat('.', 71).SelectMany(i => Enumerable.Repeat(i, 71).Append('\n')).ToArray() is { } buff && input.Split('\n').Reverse().Select(i => i.Split(',')).Select(i => (x: int.Parse(i[0]), y: int.Parse(i[1]))).Select((i, j) => (buff[i.x + i.y * 72] = '#') is { } ? (i, j) : (i, j)).ToArray() is { } locations && new int[] { 1, -1, 72, -72 } is { } deltas && 0 is { } current && new Dictionary<int, int>() is { } dists && new HashSet<int>() is { } finished ? locations.First(l => (buff[l.i.x + l.i.y * 72] = '.') is { } && (finished = new HashSet<int>()) is { } && (dists = Enumerable.Range(0, buff.Length).Where(i => buff[i] == '.').ToDictionary(t => t, t => t == 0 ? 0 : int.MaxValue - 1)) is { } && Enumerable.Range(0, int.MaxValue).Select(y => dists[current]).Select(y => deltas.Select(t => current + t).Select(t => t >= 0 && t < buff.Length && dists.TryGetValue(t, out int oldDist) && oldDist > y + 1 ? dists[t] = y + 1 : 0).Count() != -1 && (finished.Add(current) & (current = dists.MinBy(t => finished.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { })).TakeWhile(t => dists.Any(t => t.Value != int.MaxValue - 1 && !finished.Contains(t.Key))).Count() is { } && dists[71 * 72 - 2] != int.MaxValue - 1).i.ToString()[1..^1].Replace(" ", "") : throw null!)).AppendLine(day(19, input => input[..input.IndexOf("\n\n")].Split(',').Select(t => t.Trim()).ToArray() is { } towels && (object)((object self, string match, int start, string?[] b, Dictionary<int, bool> cache) => cache.TryGetValue(match.AsMemory(start).GetHashCode(), out var x) ? x : (cache[match.AsMemory(start).GetHashCode()] = b.Any(f => match.Length == start || match.AsSpan(start).StartsWith(f) && ((Func<object, string, int, string?[], Dictionary<int, bool>, bool>)self)(self, match, start + f.Length, b, cache)))) is Func<object, string, int, string?[], Dictionary<int, bool>, bool> pattern ? input[input.IndexOf("\n\n")..].Split('\n').Select(t => t.Trim()).Where(t => !string.IsNullOrEmpty(t)).Count(t => pattern(pattern, t, 0, towels, new())) : throw null!, input => input[..input.IndexOf("\n\n")].Split(',').Select(t => t.Trim()).ToArray() is { } towels && (object)((object self, string match, int start, string?[] b, Dictionary<int, long> cache) => cache.TryGetValue(match.AsMemory(start).GetHashCode(), out long x) ? x : (start == match.Length ? 1 : cache[match.AsMemory(start).GetHashCode()] = b.Sum(f => match.AsSpan(start).StartsWith(f) ? ((Func<object, string, int, string?[], Dictionary<int, long>, long>)self)(self, match, start + f.Length, b, cache) : 0L))) is Func<object, string, int, string?[], Dictionary<int, long>, long> pattern ? input[input.IndexOf("\n\n")..].Split('\n').Select(t => t.Trim()).Where(t => !string.IsNullOrEmpty(t)).Sum(t => pattern(pattern, t, 0, towels, new())) : throw null!)).AppendLine(day(20, input => input.Replace("E", ".").Replace("S", ".") is { } cleanInput && input.IndexOf('\n') + 1 is { } w && new int[] { 1, -1, w, -w, } is { } deltas && (object)((int current, Func<int, IEnumerable<(int Location, int Weight)>> getEdges) => new HashSet<int>() is { } visited && new Dictionary<int, int> { { current, 0 }, } is { } costs && Enumerable.Range(0, int.MaxValue).Select(_ => getEdges(current).Select(t => costs.TryGetValue(t.Location, out int cost) ? costs[t.Location] = Math.Min(cost, costs[current] + t.Weight) : costs[t.Location] = costs[current] + t.Weight).Count()).Select(t => visited.Add(current) && (current = costs.MinBy(t => visited.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { }).TakeWhile(t => !visited.Contains(current)).Count() is { } ? costs : throw null!) is Func<int, Func<int, IEnumerable<(int Location, int Weight)>>, Dictionary<int, int>> dijkstra && dijkstra(input.IndexOf('S'), i => deltas.Select(d => i + d).Select(p => (p >= 0 && p < cleanInput.Length ? cleanInput[p] : '#', p)).Where(t => t.Item1 == '.').Select(t => (t.p, 1))) is { } dists ? dists.Select(t => (Location: t.Key, Distance: t.Value, ValidCheats: deltas.Select(d => t.Key + d).Where(t => t >= 0 && t < cleanInput.Length && cleanInput[t] != '.'))).Select(t => (t, t.ValidCheats.SelectMany(c => deltas.Select(d => dists.TryGetValue(c + d, out int v) ? v : int.MaxValue).Where(dist => dist != int.MaxValue).Select(d => (saved: d - t.Distance - 2, c))))).SelectMany(t => t.Item2.Select(t => t.saved)).Where(t => t >= 100).Count() : throw null!, input => input.Replace("E", ".").Replace("S", ".") is { } cleanInput && input.IndexOf('\n') + 1 is { } w && new int[] { 1, -1, w, -w, } is { } deltas && Enumerable.Range(-20, 41).SelectMany(i => /*[-20, 20]*/ Math.Abs(i) - 20 is int count ? Enumerable.Range(count, -count * 2 + 1).Select(t => (dx: i, dy: t)) : default).ToArray() is (int dx, int dy)[] taxiCircle && (object)((int current, Func<int, IEnumerable<(int Location, int Weight)>> getEdges) => new HashSet<int>() is { } visited && new Dictionary<int, int> { { current, 0 }, } is { } costs && Enumerable.Range(0, int.MaxValue).Select(_ => getEdges(current).Select(t => costs.TryGetValue(t.Location, out int cost) ? costs[t.Location] = Math.Min(cost, costs[current] + t.Weight) : costs[t.Location] = costs[current] + t.Weight).Count()).Select(t => visited.Add(current) && (current = costs.MinBy(t => visited.Contains(t.Key) ? int.MaxValue : t.Value).Key) is { }).TakeWhile(t => !visited.Contains(current)).Count() is { } ? costs : throw null!) is Func<int, Func<int, IEnumerable<(int Location, int Weight)>>, Dictionary<int, int>> dijkstra && dijkstra(input.IndexOf('S'), i => deltas.Select(d => i + d).Select(p => (p >= 0 && p < cleanInput.Length ? cleanInput[p] : '#', p)).Where(t => t.Item1 == '.').Select(t => (t.p, 1))) is { } dists ? dists.Select(t => (X: t.Key % w, Y: t.Key / w, Distance: t.Value)).SelectMany(t => taxiCircle.Select(dxy => (X: dxy.dx + t.X, Y: dxy.dy + t.Y, t.Distance, dxy.dx, dxy.dy, O: t)).Where(p => p.X > 0 && p.Y > 0 && p.Y < input.Length / w && p.X < w && dists.ContainsKey(p.X + p.Y * w)).Select(p => (CheatInfo: p, CheatScore: dists[p.X + p.Y * w] - t.Distance - (Math.Abs(p.dx) + Math.Abs(p.dy)))).Where(t => t.CheatScore >= 100)).Count() : throw null!)).AppendLine(day(21, input => (object)(((int x, int y) a, (int x, int y) b) => (a.x - b.x, a.y - b.y)) is Func<(int, int), (int, int), (int X, int Y)> sub && (object)(((int x, int y) a, (int x, int y) b) => (a.x + b.x, a.y + b.y)) is Func<(int, int), (int, int), (int, int)> add && new Dictionary<char, (int, int)> { { 'A', (0, 0) }, { '^', (-1, 0) }, { '<', (-2, 1) }, { 'v', (-1, 1) }, { '>', (0, 1) }, } is { } directional && new Dictionary<char, (int, int)> { { 'A', (0, 0) }, { '0', (-1, 0) }, { '1', (-2, -1) }, { '2', (-1, -1) }, { '3', (0, -1) }, { '4', (-2, -2) }, { '5', (-1, -2) }, { '6', (0, -2) }, { '7', (-2, -3) }, { '8', (-1, -3) }, { '9', (0, -3) }, } is { } numeric && (object)((object self, (int, int) current, char type, int depth, Dictionary<((int, int), (int, int), int), long> cache) => (depth == 0 ? numeric : directional)[type] is { } next && current is { } oldCurrent && sub(next, current) is { } delta && cache.TryGetValue((current, next, depth), out long cachedValue) ? cachedValue : new System.Text.StringBuilder() switch { var s when delta.X < 0 && (current = add(current, (delta.X, 0))) is (-2, 0) => s.Append(delta.Y < 0 ? '^' : 'v', Math.Abs(delta.Y)).Append('<', -delta.X).Append('A'), var s when delta.X < 0 => s.Append('<', -delta.X), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.Y > 0 && (current = add(current, (0, delta.Y))) is (-2, 0) => s.Append(delta.X < 0 ? '<' : '>', Math.Abs(delta.X)).Append('v', delta.Y).Append('A'), var s when delta.Y > 0 => s.Append('v', delta.Y), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.Y < 0 && (current = add(current, (0, delta.Y))) is (-2, 0) => s.Append(delta.X < 0 ? '<' : '>', Math.Abs(delta.X)).Append('^', -delta.Y).Append('A'), var s when delta.Y < 0 => s.Append('^', -delta.Y), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.X > 0 && (current = add(current, (delta.X, 0))) is (-2, 0) => s.Append(delta.Y < 0 ? '^' : 'v', Math.Abs(delta.Y)).Append('>', delta.X).Append('A'), var s when delta.X > 0 => s.Append('>', delta.X).Append('A'), var s when true => s.Append('A'), } is System.Text.StringBuilder sb ? cache[(oldCurrent, next, depth)] = cachedValue = depth == 2/*5*/ ? sb.Length : sb.ToString().Aggregate((pos: (0, 0), accum: 0L), (acc, c) => (directional[c], acc.Item2 + ((Func<object, (int, int), char, int, Dictionary<((int, int), (int, int), int), long>, long>)self)(self, acc.pos, c, depth + 1, cache))).accum : throw null!) is Func<object, (int, int), char, int, Dictionary<((int, int), (int, int), int), long>, long> genSeq && new Dictionary<((int, int), (int, int), int), long>() is { } cache ? input.Split('\n').Select(i => i.Aggregate((pos: (0, 0), accum: 0L), (acc, c) => (numeric[c], acc.accum + genSeq(genSeq, acc.pos, c, 0, cache))).accum * int.Parse(i.AsSpan()[..^1])).Sum() : throw null!, input => (object)(((int x, int y) a, (int x, int y) b) => (a.x - b.x, a.y - b.y)) is Func<(int, int), (int, int), (int X, int Y)> sub && (object)(((int x, int y) a, (int x, int y) b) => (a.x + b.x, a.y + b.y)) is Func<(int, int), (int, int), (int, int)> add && new Dictionary<char, (int, int)> { { 'A', (0, 0) }, { '^', (-1, 0) }, { '<', (-2, 1) }, { 'v', (-1, 1) }, { '>', (0, 1) }, } is { } directional && new Dictionary<char, (int, int)> { { 'A', (0, 0) }, { '0', (-1, 0) }, { '1', (-2, -1) }, { '2', (-1, -1) }, { '3', (0, -1) }, { '4', (-2, -2) }, { '5', (-1, -2) }, { '6', (0, -2) }, { '7', (-2, -3) }, { '8', (-1, -3) }, { '9', (0, -3) }, } is { } numeric && (object)((object self, (int, int) current, char type, int depth, Dictionary<((int, int), (int, int), int), long> cache) => (depth == 0 ? numeric : directional)[type] is { } next && current is { } oldCurrent && sub(next, current) is { } delta && cache.TryGetValue((current, next, depth), out long cachedValue) ? cachedValue : new System.Text.StringBuilder() switch { var s when delta.X < 0 && (current = add(current, (delta.X, 0))) is (-2, 0) => s.Append(delta.Y < 0 ? '^' : 'v', Math.Abs(delta.Y)).Append('<', -delta.X).Append('A'), var s when delta.X < 0 => s.Append('<', -delta.X), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.Y > 0 && (current = add(current, (0, delta.Y))) is (-2, 0) => s.Append(delta.X < 0 ? '<' : '>', Math.Abs(delta.X)).Append('v', delta.Y).Append('A'), var s when delta.Y > 0 => s.Append('v', delta.Y), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.Y < 0 && (current = add(current, (0, delta.Y))) is (-2, 0) => s.Append(delta.X < 0 ? '<' : '>', Math.Abs(delta.X)).Append('^', -delta.Y).Append('A'), var s when delta.Y < 0 => s.Append('^', -delta.Y), var s when true => s, } switch { var s when s.Length > 0 && s[^1] == 'A' => s, var s when delta.X > 0 && (current = add(current, (delta.X, 0))) is (-2, 0) => s.Append(delta.Y < 0 ? '^' : 'v', Math.Abs(delta.Y)).Append('>', delta.X).Append('A'), var s when delta.X > 0 => s.Append('>', delta.X).Append('A'), var s when true => s.Append('A'), } is System.Text.StringBuilder sb ? cache[(oldCurrent, next, depth)] = cachedValue = depth == 25 ? sb.Length : sb.ToString().Aggregate((pos: (0, 0), accum: 0L), (acc, c) => (directional[c], acc.Item2 + ((Func<object, (int, int), char, int, Dictionary<((int, int), (int, int), int), long>, long>)self)(self, acc.pos, c, depth + 1, cache))).accum : throw null!) is Func<object, (int, int), char, int, Dictionary<((int, int), (int, int), int), long>, long> genSeq && new Dictionary<((int, int), (int, int), int), long>() is { } cache ? input.Split('\n').Select(i => i.Aggregate((pos: (0, 0), accum: 0L), (acc, c) => (numeric[c], acc.accum + genSeq(genSeq, acc.pos, c, 0, cache))).accum * int.Parse(i.AsSpan()[..^1])).Sum() : throw null!)).AppendLine(day(22, input => input.Split('\n').Select(long.Parse).Select(t => Enumerable.Range(0, 2000).Aggregate(t, (s, _) => ((s << 6) ^ s) % 16777216 is { } s1 && ((s1 >> 5) ^ s1) % 16777216 is { } s2 && ((s2 << 11) ^ s2) % 16777216 is { } s3 ? s3 : throw null!)).Sum(), input => input.Split('\n').Select(long.Parse).Aggregate(new Dictionary<(int, int, int, int), Dictionary<long, int>>(), (prev, t) => Enumerable.Range(1, 2000).Aggregate((D: new Dictionary<int, (int Cost, int Delta)> { { 0, ((int)(t % 10), 0) } }, P: t), (s, i) => (((s.P << 6) ^ s.P) % 16777216 is { } s1 && ((s1 >> 5) ^ s1) % 16777216 is { } s2 && ((s2 << 11) ^ s2) % 16777216 is { } s3 ? s3 : throw null!) is { } next && s.D.TryAdd(i, ((int)(next % 10), (int)(next % 10) - (int)(s.P % 10))) ? (s.D, next) : throw null!).D.Select(t => t.Value).Skip(1).ToArray() is { } x && x.Select((_, i) => x.Skip(i).Take(4).ToArray()).Where(t => t.Length == 4).Select(t => (cost: t[3].Cost, deltas: (t[0].Delta, t[1].Delta, t[2].Delta, t[3].Delta))).Select(i => prev.TryGetValue(i.deltas, out var dict) ? dict.TryGetValue(t, out int value) ? false : (dict[t] = i.cost) is { } : (prev[i.deltas] = new Dictionary<long, int> { { t, i.cost } }) is null).Count() is not -1 ? prev : throw null!).Select(t => t.Value.Sum(t => t.Value)).Max())).AppendLine(day(23, input => input.Split('\n').Select(t => (new string(t.AsSpan(0, 2)), new string(t.AsSpan(3, 2)))).SelectMany(t => new (string A, string B)[] { t, (t.Item2, t.Item1) }).Aggregate(new Dictionary<string, HashSet<string>>(), (dic, str) => (System.Runtime.InteropServices.CollectionsMarshal.GetValueRefOrAddDefault(dic, str.A, out _) ??= new()).Add(str.B) ? dic : dic) is { } edges ? edges.Where(t => t.Value.Count >= 2 && t.Key[0] == 't').SelectMany(t => t.Value.Append(t.Key).SelectMany(s => t.Value.Select(z => (s, z))).SelectMany(s => t.Value.Select(z => (A: s.s, B: s.z, C: z))).Where(t => t.A[0] == 't' || t.B[0] == 't' || t.C[0] == 't').Where(t => edges[t.A].Contains(t.B) && edges[t.A].Contains(t.C) && edges[t.B].Contains(t.C))).DistinctBy(t => unchecked(t.A.GetHashCode() + t.B.GetHashCode() + t.C.GetHashCode())).Count() : throw null!, input => input.Split('\n').Select(t => (new string(t.AsSpan(0, 2)), new string(t.AsSpan(3, 2)))).SelectMany(t => new (string A, string B)[] { t, (t.Item2, t.Item1) }).Aggregate(new Dictionary<string, HashSet<string>>(), (dic, str) => (System.Runtime.InteropServices.CollectionsMarshal.GetValueRefOrAddDefault(dic, str.A, out _) ??= new()).Add(str.B) ? dic : dic) is { } edges && new HashSet<string>() is { } visited && new HashSet<string>() is { } maxClique && edges.Where(e => !visited.Contains(e.Key)).Select(e => new HashSet<string> { e.Key } is { } clique && e.Value.Where(s => clique.All(c => edges[c].Contains(s))).Select(s => clique.Add(s)).Count() > -1 ? clique : throw null!).Select(e => e.Count > maxClique.Count ? maxClique = e : null).Count() != -1 ? string.Join(',', maxClique.OrderBy(t => t)) : throw null!)).AppendLine(day(24, input => input.Split("\n\n") is { } sect && System.Text.RegularExpressions.Regex.Matches(sect[0], @"([a-z]\d+)..(\d)").Select(m => (m.Groups[1].ToString(), int.Parse(m.Groups[2].ValueSpan) == 1)).ToDictionary(m => m.Item1, m => m.Item2) is { } circuitValues && System.Text.RegularExpressions.Regex.Matches(sect[1], @"(\w+).(\w+).(\w+)....(\w+)").Select(m => (A: m.Groups[1].Value, OP: m.Groups[2].Value, B: m.Groups[3].Value, Out: m.Groups[4].Value)).ToArray() is (string A, string OP, string B, string Out)[] thing && Enumerable.Range(0, int.MaxValue).Select(_ => thing = thing.Where(t => !(circuitValues.TryGetValue(t.A, out var av) && circuitValues.TryGetValue(t.B, out var bv) && ((circuitValues[t.Out] = t.OP switch { "AND" => av & bv, "OR" => av | bv, "XOR" => av ^ bv, _ => throw new Exception("unknown op"), }) | true))).ToArray()).TakeWhile(t => thing.Length > 0).Count() != -1 ? circuitValues.Where(k => k.Key.StartsWith('z')).Select(k => (int.Parse(k.Key.AsSpan(1)), k.Value)).OrderBy(i => -i.Item1).Select(i => i.Item2).Aggregate(0L, (accum, n) => (accum << 1) | (n ? 1L : 0L)) : throw null!, input => input.Split("\n\n") is { } sect && System.Text.RegularExpressions.Regex.Matches(sect[0], @"([a-z]\d+)..(\d)").Select(m => (m.Groups[1].ToString(), int.Parse(m.Groups[2].ValueSpan) == 1)).ToDictionary(m => m.Item1, m => m.Item2) is { } circuitValues && System.Text.RegularExpressions.Regex.Matches(sect[1], @"(\w+).(\w+).(\w+)....(\w+)").Select(m => (A: m.Groups[1].Value, OP: m.Groups[2].Value, B: m.Groups[3].Value, Out: m.Groups[4].Value)).ToArray() is { } gates && (circuitValues.Where(k => k.Key.StartsWith('x')).Select(k => (int.Parse(k.Key.AsSpan(1)), k.Value)).OrderByDescending(t => t.Item1).Aggregate(0L, (accum, n) => (accum << 1) | (n.Value ? 1L : 0L)) + circuitValues.Where(k => k.Key.StartsWith('y')).Select(k => (int.Parse(k.Key.AsSpan(1)), k.Value)).OrderByDescending(t => t.Item1).Aggregate(0L, (accum, n) => (accum << 1) | (n.Value ? 1L : 0L))) is { } answer && gates.Select((g, i) => (i, g)).Aggregate(new Dictionary<string, HashSet<(int ID, (string A, string OP, string B, string Out))>>(), (d, s) => ((System.Runtime.InteropServices.CollectionsMarshal.GetValueRefOrAddDefault(d, s.g.A, out _) ??= new()).Add((s.i, s.g)) && (System.Runtime.InteropServices.CollectionsMarshal.GetValueRefOrAddDefault(d, s.g.B, out _) ??= new()).Add((s.i, s.g))) ? d : d) is { } wireToGate && gates.Select((w, i) => (ID: i, w.OP, w.Out, w.A, w.B, Set: wireToGate.TryGetValue(w.Out, out var v) ? v : new())).Where(w => (!(w.OP switch { "OR" => w.Set.Any(g => g.Item2.OP == "XOR"), "AND" => w.Set.Any(g => g.Item2.OP == "OR"), "XOR" => w.Set.Any(g => g.Item2.OP == "XOR") || w.Out[0] == 'z', _ => throw new Exception("Unknown Op") }) && (w.OP != "AND" || !(wireToGate["y00"].Any(i => i.ID == w.ID) && wireToGate["x00"].Any(i => i.ID == w.ID))) || (w.OP == "XOR" && gates.Where(g => (g.A == w.Out || g.B == w.Out) && g.OP == "AND" && gates.Count(g1 => g1.OP == "XOR" && (g1.Out == g.A || g1.Out == g.B)) >= 2).Any() && gates.Any(g => g.OP == "XOR" && (g.Out == w.A || g.Out == w.B))))).OrderBy(t => t.Out).Reverse().Skip(1).ToArray() is { } candidates ? string.Join(',', candidates.Select(c => c.Out).Order()) : throw null!)).AppendLine(day(25, input => Array.Empty<object>().Aggregate(input.Split("\n\n").Select(g => (K: g[0], Data: g.Split('\n'))).Select(g => (g.K, Data: g.K == '#' ? g.Data : g.Data.Reverse())).Select(g => (g.K, Enumerable.Range(0, 5).Select(i => g.Data.Select((j, i) => (i, j)).First(t => t.j[i] == '.').i))).Aggregate(new Dictionary<char, HashSet<int[]>>(), (acc, n) => (System.Runtime.InteropServices.CollectionsMarshal.GetValueRefOrAddDefault(acc, n.K, out _) ??= new()).Add(n.Item2.ToArray()) ? acc : acc), (_, _) => null!, c => c['.'].Sum(l => c['#'].Count(k => k.Zip(l).All(t => t.First + t.Second <= 7)))), input => "Merry Christmas!")) : throw null!);